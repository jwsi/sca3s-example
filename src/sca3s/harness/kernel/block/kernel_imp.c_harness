/* Copyright (C) 2018 SCARV project <info@scarv.org>
 *
 * Use of this source code is restricted per the MIT license, a copy of which 
 * can be found at https://opensource.org/licenses/MIT (or should be included 
 * as LICENSE.txt within the associated archive or repository).
 */

// ============================================================================

#if   ( KERNEL_NAMEOF == KERNEL_NAMEOF_GENERIC   )
#define __KERNEL_NAMEOF "generic"
#elif ( KERNEL_NAMEOF == KERNEL_NAMEOF_AES       )
#define __KERNEL_NAMEOF "aes"
#endif

#if   ( KERNEL_MODEOF == KERNEL_MODEOF_DEFAULT   )
#define __KERNEL_MODEOF "default"
#elif ( KERNEL_MODEOF == KERNEL_MODEOF_ENC       )
#define __KERNEL_MODEOF "enc"
#elif ( KERNEL_MODEOF == KERNEL_MODEOF_DEC       )
#define __KERNEL_MODEOF "dec"
#endif

#define KERNEL_ID VERSION ":" KERNEL ":" __KERNEL_NAMEOF "/" __KERNEL_MODEOF

// ----------------------------------------------------------------------------

#pragma message( "?kernel"   " = "     KERNEL_ID           )

#if   ( KERNEL_MODEOF == KERNEL_MODEOF_DEFAULT   )
#pragma message( ">kernel"   " = "     "esr" "," "k,m"     )
#pragma message( "<kernel"   " = " "fec,fcc" ","   "c"     )
#elif ( KERNEL_MODEOF == KERNEL_MODEOF_ENC       )
#pragma message( ">kernel"   " = "     "esr" "," "k,m"     )
#pragma message( "<kernel"   " = " "fec,fcc" ","   "c"     )
#elif ( KERNEL_MODEOF == KERNEL_MODEOF_DEC       )
#pragma message( ">kernel"   " = "     "esr" "," "k,c"     )
#pragma message( "<kernel"   " = " "fec,fcc" ","   "m"     )
#endif

#pragma message( "?data fec" " = " "<"                     )
#pragma message( "?data fcc" " = " "<"                     )
#pragma message( "?data esr" " = " ">"                     )
#if   ( KERNEL_MODEOF == KERNEL_MODEOF_DEFAULT   )
#pragma message( "?data k"   " = " ">$"                    )
#pragma message( "?data m"   " = " ">"                     )
#pragma message( "?data c"   " = " "<"                     )
#elif ( KERNEL_MODEOF == KERNEL_MODEOF_ENC       )
#pragma message( "?data k"   " = " ">$"                    )
#pragma message( "?data m"   " = " ">"                     )
#pragma message( "?data c"   " = " "<"                     )
#elif ( KERNEL_MODEOF == KERNEL_MODEOF_DEC       )
#pragma message( "?data k"   " = " ">$"                    )
#pragma message( "?data m"   " = " "<"                     ) 
#pragma message( "?data c"   " = " ">"                     )
#endif

#pragma message( "|data fec" " = " INT(       SIZEOF_FEC)  )
#pragma message( "|data fcc" " = " INT(       SIZEOF_FCC)  )
#pragma message( "|data esr" " = " INT(KERNEL_SIZEOF_ESR)  )
#pragma message( "|data k"   " = " INT(KERNEL_SIZEOF_K  )  )
#pragma message( "|data m"   " = " INT(KERNEL_SIZEOF_M  )  )
#pragma message( "|data c"   " = " INT(KERNEL_SIZEOF_C  )  )

#pragma message( "#data fec" " = " INT(       SIZEOF_FEC)  )
#pragma message( "#data fcc" " = " INT(       SIZEOF_FCC)  )
#pragma message( "#data esr" " = " INT(KERNEL_SIZEOF_ESR)  )
#pragma message( "#data k"   " = " INT(KERNEL_SIZEOF_K  )  )
#pragma message( "#data m"   " = " INT(KERNEL_SIZEOF_M  )  )
#pragma message( "#data c"   " = " INT(KERNEL_SIZEOF_C  )  )

// ============================================================================

/** @brief      A register that contains the externally supplied randomness.
  */

uint8_t esr[ KERNEL_SIZEOF_ESR ] = { KERNEL_INITOF_ESR };

/** @brief      A register that contains the function exit code.
  */

kernel_fec_t fec = KERNEL_FEC_SUCCESS;

/** @brief      A register that contains the function cycle count.
  */

kernel_fcc_t fcc = 0;

/** @brief      A register that contains the cipher key.
  */

uint8_t   k[ KERNEL_SIZEOF_K   ] = { KERNEL_INITOF_K   };

/** @brief      A register that contains the  plaintext data.
  */

uint8_t   m[ KERNEL_SIZEOF_M   ] = { KERNEL_INITOF_M   };

/** @brief      A register that contains the ciphertext data.
  */

uint8_t   c[ KERNEL_SIZEOF_C   ] = { KERNEL_INITOF_C   };

// ----------------------------------------------------------------------------

/** @brief      Generate a kernel identifier string.
  *
  * @param[out] x a (pointer to a) buffer into which the identifier string is copied
  *
  * @note       By convention, the identifier string constitutes a sequence 
  *             of colon-separated fields; to allow the string to be parsed, 
  *             the first two fields must be \c VERSION and \c KERNEL.
  */

void kernel_id( char* x ) {
  strcpy( x, KERNEL_ID );
}

/** @brief      Execute a NOP.
  *
  * @return     an instance of \c kernel_fec_t, 
  *             e.g.,
  *             \c KERNEL_FEC_FAILURE to indicate failure
  *             or 
  *             \c KERNEL_FEC_SUCCESS to indicate success;
  *             this is captured in \c fec, the function exit code register.
  */

kernel_fec_t kernel_nop() {
  return KERNEL_FEC_SUCCESS;
}

kernel_fec_t kernel_prologue();
kernel_fec_t kernel();
kernel_fec_t kernel_epilogue();

/** @brief      A specification of the
  *             registers
  *             accessible within the kernel.
  *
  * @note       By setting \c .id equal to \c NULL, the entry will act as a
  *             terminator for the array; such a terminator entry must exist
  *             as the final entry.
  */

kernel_data_spec_t kernel_data_spec[] = {
// kernel-agnostic
  { .id = "esr", .data = ( uint8_t* )(  esr ), .size = KERNEL_SIZEOF_ESR, .used = ( uint8_t* )( NULL ), .type = KERNEL_DATA_TYPE_I                      },
  { .id = "fec", .data = ( uint8_t* )( &fec ), .size =        SIZEOF_FEC, .used = ( uint8_t* )( NULL ), .type = KERNEL_DATA_TYPE_O                      },
  { .id = "fcc", .data = ( uint8_t* )( &fcc ), .size =        SIZEOF_FCC, .used = ( uint8_t* )( NULL ), .type = KERNEL_DATA_TYPE_O                      },
// kernel-specific
#if   ( KERNEL_MODEOF == KERNEL_MODEOF_DEFAULT   )
  { .id =   "k", .data = ( uint8_t* )(    k ), .size = KERNEL_SIZEOF_K,   .used = ( uint8_t* )( NULL ), .type = KERNEL_DATA_TYPE_I | KERNEL_DATA_TYPE_S },
  { .id =   "m", .data = ( uint8_t* )(    m ), .size = KERNEL_SIZEOF_M,   .used = ( uint8_t* )( NULL ), .type = KERNEL_DATA_TYPE_I                      },
  { .id =   "c", .data = ( uint8_t* )(    c ), .size = KERNEL_SIZEOF_C,   .used = ( uint8_t* )( NULL ), .type = KERNEL_DATA_TYPE_O                      },
#elif ( KERNEL_MODEOF == KERNEL_MODEOF_ENC       )
  { .id =   "k", .data = ( uint8_t* )(    k ), .size = KERNEL_SIZEOF_K,   .used = ( uint8_t* )( NULL ), .type = KERNEL_DATA_TYPE_I | KERNEL_DATA_TYPE_S },
  { .id =   "m", .data = ( uint8_t* )(    m ), .size = KERNEL_SIZEOF_M,   .used = ( uint8_t* )( NULL ), .type = KERNEL_DATA_TYPE_I                      },
  { .id =   "c", .data = ( uint8_t* )(    c ), .size = KERNEL_SIZEOF_C,   .used = ( uint8_t* )( NULL ), .type = KERNEL_DATA_TYPE_O                      },
#elif ( KERNEL_MODEOF == KERNEL_MODEOF_DEC       )
  { .id =   "k", .data = ( uint8_t* )(    k ), .size = KERNEL_SIZEOF_K,   .used = ( uint8_t* )( NULL ), .type = KERNEL_DATA_TYPE_I | KERNEL_DATA_TYPE_S },
  { .id =   "m", .data = ( uint8_t* )(    m ), .size = KERNEL_SIZEOF_M,   .used = ( uint8_t* )( NULL ), .type = KERNEL_DATA_TYPE_O                      },
  { .id =   "c", .data = ( uint8_t* )(    c ), .size = KERNEL_SIZEOF_C,   .used = ( uint8_t* )( NULL ), .type = KERNEL_DATA_TYPE_I                      },
#endif
// terminator
  { .id =  NULL, .data = ( uint8_t* )( NULL ), .size = 0,                 .used = ( uint8_t* )( NULL ), .type = 0                                       }
};

/** @brief      A specification of the
  *             functions
  *             accessible within the kernel.
  */

kernel_func_spec_t kernel_func_spec   = {
  .kernel_id       = kernel_id,

  .kernel_prologue = kernel_prologue,
  .kernel          = kernel,
  .kernel_epilogue = kernel_epilogue,

  .kernel_nop      = kernel_nop
};

// ============================================================================
